### data from H9, HUES62 & PGP1 cells, generated by Daniella & processed by Yan before
### reprocessing using GRCh38_and_mm10 reference
### to save time, only processing the cells that are annotated as singlet by Yan's processing

setwd('/media/Scratch_SSD_Voyager/sammi/RNA_editing/')

### load cellranger output - sparse count matrix (human gene + mouse gene)
library(Seurat)
library(swne)
library(cowplot)
library(stringr)

WT_CL <- list(Read10X('/media/Scratch_SSD_Voyager/sammi/H9/H9-ter1/outs/filtered_feature_bc_matrix/'),
              Read10X('/media/Scratch_SSD_Voyager/sammi/HUES62/HUES62-ter1/outs/filtered_feature_bc_matrix/'),
              Read10X('/media/Scratch_SSD_Voyager/sammi/PGP1/PGP1-ter1/outs/filtered_feature_bc_matrix/'))
names(WT_CL) <- c("H9","HUES62","PGP1")
WT_CL

### process count matrix (remove mouse genes and omit 'GRCh38' from human genes before creating the seurat obj)
WT_CL_cleanup.list <- list()
for (i in 1:length(WT_CL)){
  genes.keep <- rownames(WT_CL[i][[1]])[!grepl("^mm10", rownames(WT_CL[i][[1]]))]
  WT_CL_cleanup.list[i][[1]] <- WT_CL[i][[1]][genes.keep,]
  
  row.names(WT_CL_cleanup.list[i][[1]]) <- sapply(strsplit(row.names(WT_CL_cleanup.list[i][[1]]), split = "GRCh38_"),"[[",2)
}
WT_CL <- WT_CL_cleanup.list
rm(WT_CL_cleanup.list)

### create initial seuratobj
WT_CL_SO.list <- list()
for (i in 1:length(WT_CL)){
  WT_CL_SO.list[i][[1]] <- CreateSeuratObject(counts = WT_CL[[i]], project = "WT_CL",
                                           min.cells = round(0.001*ncol(WT_CL[[i]])), min.features = 50)
}

### gene clean up (mito & ribo)
# count mito gene percent & remove mito gene
WT_CL_SO.list.cleanup <- list()
for (i in 1:length(WT_CL_SO.list)){
  WT_CL_SO.list[i][[1]][["percent.mt"]] <- PercentageFeatureSet(WT_CL_SO.list[i][[1]], pattern = "^MT-")
  
  genes.keep <- rownames(WT_CL_SO.list[i][[1]])[!grepl("^MT-", rownames(WT_CL_SO.list[i][[1]]))]
  WT_CL_SO.list.cleanup[i][[1]] <- subset(WT_CL_SO.list[i][[1]], features = genes.keep)
  
  counts.temp <- GetAssayData(WT_CL_SO.list.cleanup[i][[1]], assay = "RNA")
  WT_CL_SO.list.cleanup[i][[1]] <- CreateSeuratObject(counts.temp,
                                                   meta.data = WT_CL_SO.list.cleanup[i][[1]]@meta.data)
  rm(counts.temp,genes.keep)
}
head(WT_CL_SO.list.cleanup[1][[1]]@meta.data)
row.names(WT_CL_SO.list.cleanup[1][[1]])
grep("^MT-", row.names(WT_CL_SO.list.cleanup[1][[1]]))

WT_CL_SO.list <- WT_CL_SO.list.cleanup
rm(WT_CL_SO.list.cleanup)

names(WT_CL_SO.list) <- c("H9","HUES62","PGP1")

# remove noncoding RNAs - RP11 is NOT in the gene names rn, decide to skip this removal for now unless ribo genes are driving
grep("^RP11-", row.names(WT_CL_SO.list[1][[1]]))

#--------------------------------------------------------------
# this section is taken directly from https://github.com/yanwu2014/teratoma-analysis-code/blob/fd1be4e669027236e20a7d85e1cccf4d9a0743d2/Figure2/01_cell_line_clustering.R#L14

### subset to singlet previously defined
input.counts.file <- "dm-ter-chimera-merged/"
input.species.file <- "dm-ter-chimera-merged_species_class.csv"
input.doublets.file <- "dm-ter-chimera-merged_doublets.txt"

## Load the dataset
counts <- Read10X(input.counts.file)
counts <- counts[grepl("hg19", rownames(counts)),]

cell.class.df <- read.table(input.species.file, sep = ",", header = T,
                            stringsAsFactors = F)
cell.class.df <- subset(cell.class.df, call == "hg19")
counts <- counts[,colnames(counts) %in% cell.class.df$barcode]

counts <- counts[Matrix::rowSums(counts) > 20,]; dim(counts);
# write.table(as.matrix(counts), file = "dm-ter-chimera-merged.dense.matrix.tsv", 
#             sep = "\t")

## Remove doublets in barcoded dataset filtered with DoubletDetection
doublets <- as.logical(scan(input.doublets.file, sep = "\n", what = numeric()))
stopifnot(length(doublets) == ncol(counts))
doublets[is.na(doublets)] <- 1; sum(doublets)/length(doublets);
counts <- counts[,!doublets]
dim(counts)
#[1] 20713 22870

## Pull out teratoma id
batch <- factor(sapply(colnames(counts), ExtractField, field = 2, delim = "\\-"))
names(batch) <- colnames(counts)
levels(batch) <- c("H9", "HUES62", "PGP1")
table(batch)

#--------------------------------------------------------------

WT_CL_SO.list.cleanup <- list()
for (i in 1:length(WT_CL_SO.list)){
  WT_CL_SO.list.cleanup[i][[1]] <- RenameCells(object = WT_CL_SO.list[i][[1]], new.names = paste0(sapply(strsplit(colnames(WT_CL_SO.list[i][[1]]), split = "-"),"[[",1),"-",i))
}
colnames(WT_CL_SO.list.cleanup[2][[1]])

length(batch[which(batch == "H9")]) #5178
length(intersect(names(batch[which(batch == "H9")]), colnames(WT_CL_SO.list.cleanup[1][[1]]))) #4993
length(batch[which(batch == "HUES62")]) #6051
length(intersect(names(batch[which(batch == "HUES62")]), colnames(WT_CL_SO.list.cleanup[2][[1]])))  #6044
length(batch[which(batch == "PGP1")]) #11641
length(intersect(names(batch[which(batch == "PGP1")]), colnames(WT_CL_SO.list.cleanup[3][[1]]))) #11324

for (i in 1:length(WT_CL_SO.list.cleanup)){
  WT_CL_SO.list.cleanup[i][[1]] <- WT_CL_SO.list.cleanup[i][[1]][,colnames(WT_CL_SO.list.cleanup[i][[1]]) %in% intersect(colnames(counts), colnames(WT_CL_SO.list.cleanup[i][[1]]))]
}
sapply(WT_CL_SO.list.cleanup, dim)
# [2,]  4993  6044 11324

# check these singlet to be classified as human cells by cellranger
WT_gem_cla <- list(read.table('/media/Scratch_SSD_Voyager/sammi/H9/H9-ter1/outs/analysis/gem_classification.csv', sep = ",", header = T),
                   read.table('/media/Scratch_SSD_Voyager/sammi/HUES62/HUES62-ter1/outs/analysis/gem_classification.csv', sep = ",", header = T),
                   read.table('/media/Scratch_SSD_Voyager/sammi/PGP1/PGP1-ter1/outs/analysis/gem_classification.csv', sep = ",", header = T))

length(WT_gem_cla)
head(WT_gem_cla[[1]],6)
sapply(WT_gem_cla,dim)
# [1,] 7286 10187 18333

for (i in 1:length(WT_gem_cla)){
  WT_gem_cla[[i]]$barcode <- paste0(sapply(strsplit(WT_gem_cla[[i]]$barcode, split = "-"),"[[",1),"-",i)
}

for (i in 1:length(WT_gem_cla)){
  WT_gem_cla[[i]] <- WT_gem_cla[[i]][WT_gem_cla[[i]]$barcode %in% colnames(WT_CL_SO.list.cleanup[i][[1]]),]
}
sapply(WT_gem_cla,dim)
# [1,] 4993 6044 11324

for (i in 1:length(WT_gem_cla)){
  print(paste0("teratoma ",i," mouse: ",length(which(WT_gem_cla[[i]]$call == "mm10"))))
  print(paste0("teratoma ",i," multiplet: ",length(which(WT_gem_cla[[i]]$call == "Multiplet"))))
}
#[1] "teratoma 1 mouse: 1"
#[1] "teratoma 1 multiplet: 0"
#[1] "teratoma 2 mouse: 2"
#[1] "teratoma 2 multiplet: 6"
#[1] "teratoma 3 mouse: 3"
#[1] "teratoma 3 multiplet: 0"

# exclude mouse and multiplet cells
for (i in 1:length(WT_CL_SO.list)){
  WT_CL_SO.list.cleanup[i][[1]] <- WT_CL_SO.list.cleanup[i][[1]][,which(WT_gem_cla[[i]]$call == "GRCh38")]
}
sapply(WT_CL_SO.list.cleanup,dim)
# [2,]  4992  6036 11321

# put back all the metadata previously obtained

WT_CL_meta <- read.table('dm-ter-chimera-merged_metadata.tsv', sep = "\t", header = T)

for (i in 1:length(WT_CL_SO.list.cleanup)){
  WT_CL_SO.list.cleanup[i][[1]] <- WT_CL_SO.list.cleanup[i][[1]][, WT_CL_meta$cell]
  
  meta.temp <- WT_CL_meta$ident
  names(meta.temp) <- WT_CL_meta$cell
  WT_CL_SO.list.cleanup[i][[1]] <- AddMetaData(WT_CL_SO.list.cleanup[i][[1]], metadata = meta.temp, col.name = "cluster")
  
  meta.temp <- WT_CL_meta$cell_line
  names(meta.temp) <- WT_CL_meta$cell
  WT_CL_SO.list.cleanup[i][[1]] <- AddMetaData(WT_CL_SO.list.cleanup[i][[1]], metadata = meta.temp, col.name = "teratoma")
}
sapply(WT_CL_SO.list.cleanup, dim)
# [2,]  4869  5928 11285

head(WT_CL_SO.list.cleanup[1][[1]]@meta.data)

WT_CL_SO.list <- WT_CL_SO.list.cleanup
rm(WT_CL_SO.list.cleanup)
names(WT_CL_SO.list) <- c("H9","HUES62","PGP1")

sapply(WT_CL_SO.list, dim)
# [2,]  4869   5928 11285

### before moving to seurat, check a couple things
for (i in 1:length(WT_CL_SO.list)){
  # no cells have mouse genes
  print(length(grep("^mm10-", row.names(WT_CL_SO.list[1][[1]]))))
  
  # no cells have mito genes
  print(length(grep("^MT-", row.names(WT_CL_SO.list[1][[1]]))))
  
  # no cells are of mito per > 10
  print(length(which(WT_CL_SO.list[i][[1]]$percent.mt > 10)))
  
  # check # of cells in each library
  print(dim(WT_CL_SO.list[i][[1]])[2])
}

# a couple high mito content cells should be filtered out here
# save current seurat object list & then start seurat (filtering out these cells)


save(WT_CL_SO.list, file = "WT3CL_YWsubset_preprocessing_mitoUNfiltered_20230418.Robj")

# save violin plots pre and post filtering
p <- list(list())
for (i in 1:length(WT_CL_SO.list)){
  p[i][[1]] <- plot_grid(VlnPlot(WT_CL_SO.list[i][[1]], features = c("nFeature_RNA")) + NoLegend(),
                         VlnPlot(WT_CL_SO.list[i][[1]], features = c("nCount_RNA")) + NoLegend(),
                         VlnPlot(WT_CL_SO.list[i][[1]], features = c("percent.mt")) + NoLegend(),
                         ncol = 3, labels = names(WT_CL_SO.list)[i], scale = 0.9)
}
pdf("Supp1_CellLine_R1/Teratoma_3CL_Vln_postcellranger_prefiltered_20230418.pdf", width = 11, height = 6)
p
dev.off()

p <- list(list())
for (i in 1:length(WT_CL_SO.list)){
  WT_CL_SO.list[i][[1]] <- subset(WT_CL_SO.list[i][[1]], subset = percent.mt < 10) #& nFeature_RNA > 200 & nFeature_RNA < 4000) 
  p[i][[1]] <- plot_grid(VlnPlot(WT_CL_SO.list[i][[1]], features = c("nFeature_RNA")) + NoLegend(),
                         VlnPlot(WT_CL_SO.list[i][[1]], features = c("nCount_RNA")) + NoLegend(),
                         VlnPlot(WT_CL_SO.list[i][[1]], features = c("percent.mt")) + NoLegend(),
                         ncol = 3, labels = names(WT_CL_SO.list)[i], scale = 0.9)
}
pdf("Supp1_CellLine_R1/Teratoma_3CL_Vln_postcellranger_postfiltered_20230418.pdf", width = 11, height = 6)
p
dev.off()

sapply(WT_CL_SO.list, dim)
# [2,]  3655   4748 10638

# normalize & identify variable features for integration (4k variable genes)
for(i in 1:length(WT_CL_SO.list)) {
  WT_CL_SO.list[[i]] <- NormalizeData(object = WT_CL_SO.list[[i]], verbose = FALSE)
  WT_CL_SO.list[[i]] <- FindVariableFeatures(object = WT_CL_SO.list[[i]], selection.method = "vst", 
                                          nfeatures = 4000, verbose = F)
}

## Identify anchors and integrate (which replaces runMultiCCA)
obj.anchors <- FindIntegrationAnchors(object.list = WT_CL_SO.list, anchor.features = 4000, dims = 1:30)
obj.integrated <- IntegrateData(anchorset = obj.anchors, dims = 1:30)

## Switch to integrated assay. The variable features of this assay are 
## automatically set during IntegrateData
DefaultAssay(object = obj.integrated) <- "integrated"

# Run the standard workflow for visualization and clustering
obj.integrated <- ScaleData(object = obj.integrated, features = rownames(GetAssayData(obj.integrated)))
obj.integrated <- RunPCA(object = obj.integrated, npcs = 30, verbose = F)
obj.integrated <- RunUMAP(object = obj.integrated, reduction = "pca", 
                          dims = 1:30, metric = "cosine")

cluster_levels <- c("Radial Glia","CycProg","Early Neurons","Retinal Neurons","Retinal Epi","Schwann Cells","Melanoblasts",
                    "Foregut Epi","Mid/Hindgut Epi","Airway Epi","HSC","Immune","Erythrocyte",
                    "Adipogenic MSC/Fib","Chondrogenic MSC/Fib","Cycling MSC/Fib","MSC/Fib","MyoFib",
                    "Muscle Prog","Cardiac/Skeletal Muscle","Pericytes","Smooth Muscle",
                    "Kidney Prog")
cluster_col <- c("#4795F5","#0B62CD","#7474FF","#DADAFF","#F2B77C","#9EEA00","#4FF4A2",
                 "#002700","#005A00","#00A700","#000032","#04409B","#4545FF",
                 "#0000FF","#FF0000","#00C000","#AD07E3","#000000",
                 "#B35A00","#FF9933","#A00000","#94641F","#610051")
names(cluster_col) <- cluster_levels

pdf('Supp1_CellLine_R1/Teratoma_3CL_intUMAP_20230418.pdf', height = 10, width = 15)
plot_grid(DimPlot(WT_3CL, group.by = "cluster", label = T, repel = T, cols = cluster_col) + NoLegend(),
          DimPlot(WT_3CL, group.by = "teratoma", label = T, repel = T))
dev.off()

pdf('Supp1_CellLine_R1/Teratoma_3CL_intUMAP_split_by_CL_20230418.pdf', height = 10, width = 20)
DimPlot(WT_3CL, group.by = "cluster", label = T, repel = T, split.by = "teratoma", cols = cluster_col) + NoLegend()
dev.off()

table(WT_3CL$cluster, WT_3CL$teratoma)
write.table(table(WT_3CL$cluster, WT_3CL$teratoma), file = "Supp1_CellLine_R1/Teratoma_3CL_cellcount_20230804.txt", sep = ",", quote = F, row.names = T)


### merge some cell types for more read-out in RNA editing

obj.integrated$annot_v1 <- obj.integrated$cluster
#Neural Progenitors: RG + CycProg
obj.integrated$annot_v1[obj.integrated$cluster %in% c("Radial Glia","CycProg")] <- "Neural-Progenitors"
#Neurons: Early Neurons + Retinal Neurons
obj.integrated$annot_v1[obj.integrated$cluster %in% c("Early Neurons","Retinal Neurons")] <- "Neurons"
#SCP: Schwann + Melanobalsts
obj.integrated$annot_v1[obj.integrated$cluster %in% c("Schwann Cells","Melanoblasts")] <- "SCP"

#Gut Epithelial: Foregut Epi + Mid/Hindgut Epi + Airway Epi
obj.integrated$annot_v1[obj.integrated$cluster %in% c("Airway Epi","Foregut Epi","Mid/Hindgut Epi")] <- "Gut-Epi"

#Hematopoietic: HSC + immune + Erythrocyte
obj.integrated$annot_v1[obj.integrated$cluster %in% c("HSC","Immune","Erythrocyte")] <- "Hematopoietic"
#Muscle: Muscle Prog + Cardiac/Skeletal Muscle
obj.integrated$annot_v1[obj.integrated$cluster %in% c("Muscle Prog","Cardiac/Skeletal Muscle")] <- "Muscle"

table(obj.integrated$annot_v1)
table(obj.integrated$annot_v1, obj.integrated$teratoma)

### fix cell type names
obj.integrated$annot_v1 <- str_replace_all(string = obj.integrated$annot_v1, pattern = "/", replacement = "-")
obj.integrated$annot_v1 <- str_replace_all(string = obj.integrated$annot_v1, pattern = fixed(" "), replacement = "-")
table(obj.integrated$annot_v1)

WT_3CL <- obj.integrated

save(WT_3CL, file = "Supp1_CellLine_R1/WT3CL_YWsubset_intObj_20230418.Robj")
load("Supp1_CellLine_R1/WT3CL_YWsubset_intObj_20230418.Robj")
# Load the "scales" package
require(scales)
# Create vector with levels of object@ident
identities <- c("H9","HUES62","PGP1")
# Create vector of default ggplot2 colors
my_color_palette <- hue_pal()(length(identities))

pdf('Supp1_CellLine_R1/Teratoma_3CL_intUMAP_20230602.pdf', height = 10, width = 15)
plot_grid(DimPlot(WT_3CL, group.by = "cluster", label = T, repel = T, cols = cluster_col) + NoLegend(),
          DimPlot(WT_3CL, group.by = "teratoma", label = T, repel = T, cols = c('H9'='green', 'PGP1'='blue',"HUES62"="red")))
dev.off()

pdf('Supp1_CellLine_R1/Teratoma_3CL_intUMAP_20230602_v2.pdf', height = 10, width = 15)
plot_grid(DimPlot(WT_3CL, group.by = "cluster", label = T, repel = T, cols = cluster_col) + NoLegend(),
          DimPlot(WT_3CL, group.by = "teratoma", label = T, repel = T, cols = c('H9'='#00BA38', 'PGP1'='#619CFF',"HUES62"="#F8766D")))
dev.off()



for (i in names(table(WT_3CL$annot_v1))){
  for (j in names(table(WT_3CL$teratoma))){
    if (length (row.names(WT_3CL@meta.data[WT_3CL$annot_v1 == i & WT_3CL$teratoma == j, ])) != 0){
      write.table(paste0("CB:Z:",sapply(strsplit(row.names(WT_3CL@meta.data[WT_3CL$annot_v1 == i & WT_3CL$teratoma == j, ]), split = "-"), "[[",1), "-1"), 
                  paste0('cb_listsCL/v1/',i,'_',j,'.txt'), col.names = FALSE, row.names = FALSE, 
                  quote = FALSE, sep = ',')
    }
  }
}

### run detecting RNA editing pipeline with rediportal editing site table for reference GRCh38

## Count how many files
# ls -1 | wc -l
# 44
# run bash CL_test_parse_20230419.sh in shell
## run samtools index collapsed_bam/ter1_Adipogenic-MSC-Fib_AAVS1.bam
## run bash index_bam.sh in shell (indexing is now included in H1_test_parse.sh)
## https://github.com/CGATOxford/UMI-tools/issues/555
## run umi_tools dedup -I collapsed_bam/ter1_Adipogenic-MSC-Fib_AAVS1.bam -S dedupped_bam/ter1_Adipogenic-MSC-Fib_AAVS1_dedup.bam --umi-tag=UB --cell-tag=CB --method=unique --extract-umi-method=tag
# run bash dedup_bam_CL_20230419.sh in shell - umitools only available in iterm2
# run bash perl_bam_CL_20230420.sh in shell - also only works in iterm2

# run bash AEI_CL_20230420.sh in conda aei_v1 environment



